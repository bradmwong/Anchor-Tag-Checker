<% if (typeof linksDict !== "undefined") { %>
    <% if (Object.keys(linksDict).length > 0) { %>
        <table id="linkTable">
            <tr>
                <th>Weblink</th>
                <th>Errors</th>
            </tr>
            
            <% let startingIndex = page * quantity - quantity;
            let endingIndex = page * quantity - 1;
            let keys = Object.keys(linksDict);
            for (i = 0; i <= Object.keys(linksDict).length; i++) {
                let key = keys[i];
                if (linksDict.hasOwnProperty(key)) {
                    if (linksDict[key] !== []) {
                        if (i <= endingIndex) { %>
                            <tr class="row visible">
                        <% } else { %>
                            <tr class="row hidden">
                        <% } %>
                            <th class="row-url"><%= key %></th>
                            <th class="row-errors"><%= linksDict[key] %></th>
                        </tr>
                    <% }
                }
            } %>
        </table>


        <br>
        <span>
            <button id="previousButton">PREVIOUS</button>
            <span id="pageNumber"><%= page %></span>
            <button id="nextButton">NEXT</button>
        </span>


        <script>

            // NEXT BUTTON
            nextButton.addEventListener('click', function() {
                pageSelector('next');
            });

            // PREVIOUS BUTTON
            previousButton.addEventListener('click', function () {
                pageSelector('previous');
            })


            // Update the rows/data shown on each page
            async function pageSelector(pageSelection) {

                const nextButton = document.querySelector('#nextButton');
                const previousButton = document.querySelector('#previousButton');
                const pageField = document.querySelector('#pageNumber');
                const rows = document.querySelectorAll('.row');

                const pageQuantity = <%= quantity %>;
                const firstPage = 1;
                const lastPage = (rows.length % pageQuantity !== 0) ? (Math.floor(rows.length / pageQuantity) + 1) : (rows.length / pageQuantity);
                const pageNumber = parseInt(pageField.innerText, 10);

                // Check if first page
                if (pageSelection === 'next') {
                    if (pageNumber === lastPage) {
                        return;
                    }
                } else if (pageSelection === 'previous') {
                    if (pageNumber === firstPage) {
                        return;
                    }
                } else {
                    return;
                }

                let incompleteURLs = [];
                let startIndex = 0;
                let endIndex = 0;

                // Hide current page
                startIndex = pageNumber * pageQuantity - pageQuantity;
                endIndex = pageNumber * pageQuantity - 1;
                for (let i = startIndex; i <= endIndex; i++) {
                    if (typeof rows[i] !== "undefined") {
                        rows[i].classList.remove('visible');
                        rows[i].classList.add('hidden');
                    }
                }

                // Reveal and populate next page
                if (pageSelection === 'next') {

                    const nextPageNumber =  pageNumber + 1;
                    pageField.innerText = nextPageNumber;
                    startIndex = nextPageNumber * pageQuantity - pageQuantity;
                    endIndex = nextPageNumber * pageQuantity - 1;

                } else if (pageSelection === 'previous') {

                    const previousPageNumber = pageNumber - 1;
                    pageField.innerText = previousPageNumber;
                    startIndex = previousPageNumber * pageQuantity - pageQuantity;
                    endIndex = previousPageNumber * pageQuantity - 1;

                }
                for (let i = startIndex; i <= endIndex; i++) {
                    if (typeof rows[i] !== "undefined") {
                        const rowURL = rows[i].querySelector('.row-url').innerText;
                        const rowErrors = rows[i].querySelector('.row-errors').innerText;
                        if (rowErrors === "" || rowErrors.includes('ERROR:')) {
                            incompleteURLs.push(rowURL);
                        }
                        rows[i].classList.remove('hidden');
                        rows[i].classList.add('visible');
                    }
                }

                await sendPostRequestToUpdateErrorsColumn(incompleteURLs);
                
            }
            

            // Check for errors to update the 'Errors' column
            async function sendPostRequestToUpdateErrorsColumn(incompleteURLs) {
                
                // Check if there are URLs to check
                if (incompleteURLs.length) {
                    try {

                        const dataToSend = {
                            incompleteURLs: incompleteURLs,
                        };
                        const response = await fetch('/changePage', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(dataToSend)
                        });
                        const rowErrors = document.querySelectorAll('.row-errors');

                        // Check if response received
                        if (response.ok) {
                            
                            const responseText = await response.text();
                            const linksObject = JSON.parse(responseText);
                            
                            // Fill in 'Errors' column 
                            Object.entries(linksObject).forEach(([key, value]) => {
                                const index = findIndexRowOfURL(key);
                                if(findIndexRowOfURL(key) >= 0) {
                                    rowErrors[index].innerText = value;
                                    console.log(`updated: ${index}`)
                                }
                            });
                        
                        } else {
                            
                            // Fill in 'Errors' column 
                            for (let i = 0; i < incompleteURLs.length; i++) {
                                const index = findIndexRowOfURL(incompleteURLs[i]);
                                rowErrors[index].innerText = `ERROR: Response Status ${response.status}`;
                            }

                        }

                    } catch (error) {
                        console.error('Error:', error);
                    }
                }
            }
            
            // Returns the index row that contains the URL string
            function findIndexRowOfURL (urlString) {

                const rowURLs = document.querySelectorAll('.row-url');
                
                // Return -1 if not found
                let index = -1;
                
                // Check if URL string can be found
                for (let i = 0; i < rowURLs.length; i++) {
                    let rowURL = rowURLs[i].innerText.trim();
                    if (urlString.trim() === rowURL) {
                        index = i;
                        break;
                    }
                }

                return index;

            }

        </script>

    <% } else { %>
        <li>Unable to find any SiteMap Links</li>
    <% }; %>
<% } else { %>
    <li>linksList is undefined</li>
<% }; %>